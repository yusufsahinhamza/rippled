<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rippled: Theory of Pathfinding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rippled
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Theory of Pathfinding </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>It's a hard problem - an exponential problem - and there is a limited amount of time until the ledger changes.</p>
<p>Search for the best path, but it's impossible to guarantee the result is the best unless the ledger is small.</p>
<p>Also, the current state of the ledger can't be definitively known. We only know the state of past ledgers.</p>
<p>By the time a transaction is processed, liquidity may be taken or added. This is why payments support a maximum cost.</p>
<p>People are given estimates so they can make a decision as to whether the overall cost is good enough for them.</p>
<p>This is the <b>rippled</b> implementation; there are many other possible implementations!</p>
<p><b>rippled</b> uses a variety of search techniques:</p>
<ol type="1">
<li>Hebbian learning.<ul>
<li>Reuse found liquidity.</li>
<li>Good liquidity is often reusable.</li>
<li>When searching, limit our search to the rippled cache.</li>
</ul>
</li>
<li>Six degrees of separation.<ul>
<li>If sending value through individual's account, expect no path to have more than six hops.</li>
<li>According to <a href="https://www.facebook.com/notes/facebook-data-team/anatomy-of-facebook/10150388519243859">Facebook studies</a> as of late 2011, its users are separated by fewer than five steps.</li>
<li>By using XRP for bridging the most complicated path expected is usually:</li>
<li>source -&gt; gateway -&gt; XRP -&gt; gateway -&gt; destination</li>
</ul>
</li>
<li>Pareto principle.<ul>
<li>Good liquidity is often reusable.</li>
<li>Concentrate on the most liquid gateways to serve almost everybody.</li>
<li>People who chose to use illiquid gateways get the service level implied by their choice of poor liquidity.</li>
</ul>
</li>
<li>Monte Carlo methods.<ul>
<li>Learn new paths.</li>
<li>Search outside the <b>rippled</b> cache.</li>
<li>Distributed learning.</li>
<li>Every rippled node searches their own cache for best liquidity and then the good results get propagated to the network.</li>
<li>Whenever somebody makes a payment, the nodes involved go to the rippled cache; since payments appear in every ledger in the network, this liquidity information now appears in every rippled cache.</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md97"></a>
Life of a Payment</h1>
<h2><a class="anchor" id="autotoc_md98"></a>
Overview</h2>
<p>Making a payment in the ripple network is about finding the cheapest path between source and destination.</p>
<p>There are various stages:</p>
<p>An issue is a balance in some specific currency. An issuer is someone who "creates" a currency by creating an issue.</p>
<p>For tx processing, people submit a tx to a rippled node, which attempts to apply the tx locally first, and if succeesful, distributes it to other nodes.</p>
<p>When someone accepts payment they list their specific payment terms, "what must happen before the payment goes off." That can be done completely in the Ripple Network. Normally a payment on the Ripple net can be completely settled there. When the ledger closes, the terms are met, or they are not met.</p>
<p>For a bridge payment, based on a previous promise it will deliver payment off-network. A bridge promises to execute the final leg of a payment, but there's the possibility of default. If you want to trust a bridge for a specific pathfinding request, you need to include it in the request.</p>
<p>In contrast, a gateway is in the business of redeeming value on the Ripple Network for value off the Ripnet. A gateway is in the business of issuing balances.</p>
<p>Bitstamp is a gateway - you send 'em cash, they give you a ripple balance and vice versa. There's no promise or forwarding for a transaction.</p>
<p>A bridge is a facility that allows payments to be made from the Ripnet to off the Ripnet.</p>
<p>Suppose I'm on the Ripple network and want to send value to the bitcoin network. See: <a href="https://ripple.com/wiki/Outbound_Bridge_Payments">https://ripple.com/wiki/Outbound_Bridge_Payments</a> <a href="https://ripple.com/wiki/Services_API">https://ripple.com/wiki/Services_API</a></p>
<p>Two types of paths:</p><ol type="1">
<li>I have X amount of cash I wish to send to someone - how much will they receive?<ul>
<li>not yet implemented in pathfinding, or at least in the RPC API.<ul>
<li>TODO: find if this is implemented and either document it or file a JIRA.</li>
</ul>
</li>
</ul>
</li>
<li>I need to deliver X amount of cash to someone - how much will it cost me?</li>
</ol>
<p>Here's a transaction: <a href="https://ripple.com/wiki/Transaction_Format#Payment_.280.29">https://ripple.com/wiki/Transaction_Format#Payment_.280.29</a></p>
<p>Not implemented: bridge types.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
High level of a payment</h2>
<ol type="1">
<li>I make a request for path finding to a rippled.</li>
<li>That rippled "continuously" returns solutions until I "stop".</li>
<li>You create a transaction which includes the path set that you got from the quote.</li>
<li>You sign it.</li>
<li>You submit it to one or more rippleds.</li>
<li>Those rippled validates it, and forwards it if it;s valid.<ul>
<li>valid means "not malformed" and "can claim a fee" - the sending account has enough to cover the transaction fee.</li>
</ul>
</li>
<li>At ledger closing time, the transaction is applied by the transaction engine and the result is stored by changing the ledger and storing the tx metadata in that ledger.</li>
</ol>
<p>If you're sending and receiving XRP you don't need a path. If the union of the default paths are sufficient, you don't need a path set (see below about default paths). The idea behind path sets is to provide sufficient liquidity in the face of a changing ledger.</p>
<p>If you can compute a path already yourself or know one, you don't need to do steps 1 or 2.</p>
<ol type="1">
<li>Finding liquidity - "path finding"<ul>
<li>finding paths (exactly "path finding")</li>
<li>filtering by liquidity.<ul>
<li>take a selection of paths that should satisfy the transaction's conditions.</li>
<li>This routine is called RippleCalc::rippleCalc.</li>
</ul>
</li>
</ul>
</li>
<li>Build a payment transaction containing the path set.<ul>
<li>a path set is a group of paths that a transaction is supposed to use for liquidity</li>
<li>default paths are not included<ul>
<li>zero hop path: a default path is "source directly to destination".</li>
<li>one hop paths - because they can be derived from the source and destination currency.</li>
</ul>
</li>
<li>A payment transaction includes the following fields<ul>
<li>the source account</li>
<li>the destination account</li>
<li>destination amount<ul>
<li>contains an amount and a currency</li>
<li>if currency not XRP, must have a specified issuer.</li>
<li>If you specify an issuer then you MUST deliver that issuance to the destination.</li>
<li>If you specify the issuer as the destination account, then they will receive any of the issuances they trust.</li>
</ul>
</li>
<li>maximum source amount - maximum amount to debit the sender.<ul>
<li>This field is optional.</li>
<li>if not specified, defaults to the destination amount with the sender as issuer.</li>
<li>contains an amount and a currency</li>
<li>if currency not XRP, must have a specified issuer.</li>
<li>specifying the sender as issuer allows any of the sender's issuance to be spent.</li>
<li>specifying a specific issuer allows only that specific issuance to be sent.</li>
</ul>
</li>
</ul>
</li>
<li>path set.<ul>
<li>Optional.</li>
<li>Might contain "invalid" paths or even "gibberish" for an untrusted server.</li>
<li>An untrusted server could provide proof that their paths are actually valid.<ul>
<li>That would NOT prove that this is the cheapest path.</li>
</ul>
</li>
<li>The client needs to talk to multiple untrusted servers, get proofs and then pick the best path.</li>
<li>It's much easier to validate a proof of a path than to find one, because you need a lot of information to find one.<ul>
<li>In the future we might allow one server to validate a path offered by another server.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Executing a payment<ul>
<li>very little time, can't afford to do a search.</li>
<li>that's why we do the path building before the payment is due.</li>
<li>The routine used to compute liquidity and ledger change is also called RippleCalc::rippleCalc. </li>
</ul>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
